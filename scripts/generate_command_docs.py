#!/usr/bin/env python3
"""Generate the Commands Reference section in docs/commands.md from the Typer app.

Usage:
  python scripts/generate_command_docs.py

It introspects the Typer application in cyberzard.cli and rebuilds only the
AUTOGENERATED section between the markers in docs/commands.md.
"""
from __future__ import annotations
import inspect
from pathlib import Path
import typer
import importlib
import re

DOC_PATH = Path("docs/commands.md")
START_MARK = "<!-- AUTOGENERATED-COMMANDS-START -->"
END_MARK = "<!-- AUTOGENERATED-COMMANDS-END -->"


def load_app() -> typer.Typer:
    mod = importlib.import_module("cyberzard.cli")
    return getattr(mod, "app")


def command_signature(cmd: typer.models.CommandFunctionType) -> str:
    params = []
    sig = inspect.signature(cmd.callback)
    for name, p in sig.parameters.items():
        if name == "self":
            continue
        if p.kind in (p.VAR_KEYWORD, p.VAR_POSITIONAL):
            continue
        annotation = getattr(p.annotation, "__name__", str(p.annotation)) if p.annotation != inspect._empty else ""
        default = "" if p.default is inspect._empty else f" = {p.default!r}" if not isinstance(p.default, bool) else (" (flag)" if isinstance(p.default, bool) else "")
        params.append(f"{name}{default}{(':'+annotation) if annotation else ''}")
    return ", ".join(params)


def build_table(app: typer.Typer) -> str:
    rows = ["| Command | Summary | Signature |", "|---------|---------|-----------|"]
    for name, cmd in app.registered_commands:
        help_text = (cmd.help or cmd.callback.__doc__ or "").strip().splitlines()[0][:80]
        rows.append(f"| {name} | {help_text} | `{command_signature(cmd)}` |")
    return "\n".join(rows)


def replace_section(original: str, new_block: str) -> str:
    if START_MARK not in original or END_MARK not in original:
        # append section at end
        return original.rstrip() + f"\n\n{START_MARK}\n{new_block}\n{END_MARK}\n"
    pattern = re.compile(f"{START_MARK}.*?{END_MARK}", re.DOTALL)
    return pattern.sub(f"{START_MARK}\n{new_block}\n{END_MARK}", original)


def main():
    app = load_app()
    table = build_table(app)
    content = DOC_PATH.read_text(encoding="utf-8")
    updated = replace_section(content, table)
    DOC_PATH.write_text(updated + ("\n" if not updated.endswith("\n") else ""), encoding="utf-8")
    print("Updated commands documentation.")


if __name__ == "__main__":  # pragma: no cover
    main()
